{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My wiki Simple Wiki to track notes and code snippets.","title":"My wiki"},{"location":"#my-wiki","text":"Simple Wiki to track notes and code snippets.","title":"My wiki"},{"location":"dev/linux/","text":"Linux netplan ubuntu server # This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: enp0s3: addresses: - 10.0.0.1/24 nameservers: addresses: - 10.0.0.2 search: [] routes: - to: default via: 10.0.0.254 version: 2 usermod usermod -aG sudo username Adding k9s o binari a PATH # If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH export PATH=/usr/lib/python3.10:$PATH export PATH=/snap/k9s/current/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"$HOME/.oh-my-zsh\"","title":"Linux"},{"location":"dev/linux/#linux","text":"","title":"Linux"},{"location":"dev/linux/#netplan-ubuntu-server","text":"# This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: enp0s3: addresses: - 10.0.0.1/24 nameservers: addresses: - 10.0.0.2 search: [] routes: - to: default via: 10.0.0.254 version: 2","title":"netplan ubuntu server"},{"location":"dev/linux/#usermod","text":"usermod -aG sudo username","title":"usermod"},{"location":"dev/linux/#adding-k9s-o-binari-a-path","text":"# If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH export PATH=/usr/lib/python3.10:$PATH export PATH=/snap/k9s/current/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"$HOME/.oh-my-zsh\"","title":"Adding k9s o binari a PATH"},{"location":"dev/microservices/","text":"Microservices In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. From https://martinfowler.com/articles/microservices.html Kubectl https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client","title":"Microservices"},{"location":"dev/microservices/#microservices","text":"In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. From https://martinfowler.com/articles/microservices.html","title":"Microservices"},{"location":"dev/microservices/#kubectl","text":"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client","title":"Kubectl"},{"location":"dev/mkdocs/","text":"Mkdocs doc: https://www.mkdocs.org/user-guide/writing-your-docs/ Installazione python3 -m venv venv source venv/bin/activate python3 -m pip install mkdocs pip freeze > requirements.txt echo \"venv/\" >> .gitignore echo \"site/\" >> .gitignore Local dev mkdocs serve Update code mkdocs build mkdocs gh-deploy --config-file ../mkdocs.yml --remote-branch main","title":"Mkdocs"},{"location":"dev/mkdocs/#mkdocs","text":"doc: https://www.mkdocs.org/user-guide/writing-your-docs/","title":"Mkdocs"},{"location":"dev/mkdocs/#installazione","text":"python3 -m venv venv source venv/bin/activate python3 -m pip install mkdocs pip freeze > requirements.txt echo \"venv/\" >> .gitignore echo \"site/\" >> .gitignore","title":"Installazione"},{"location":"dev/mkdocs/#local-dev","text":"mkdocs serve","title":"Local dev"},{"location":"dev/mkdocs/#update-code","text":"mkdocs build mkdocs gh-deploy --config-file ../mkdocs.yml --remote-branch main","title":"Update code"},{"location":"dev/python/","text":"Python Show Python PATH python3 -c \"import sys;print('\\n'.join(sys.path))\" ModuleNotFoundError in virtualenv Si risolve puntanto al percorso python nel virtualenv sudo venv/bin/python3 main.py Datetime now = datetime.now().strftime(CLOCK_STR)) icmplib from icmplib import ping import time from datetime import datetime import threading #CLOCK_STR = \"%m/%d/%Y, %H:%M:%S\" CLOCK_STR = \"%H:%M:%S.%f\" host_list = [\"192.168.1.1\", \"dns.google.com\"] #host_list = [\"repubblica.it\", \"dns.google.com\"] SOGLIA_RTT = 10 SOGLIA_LOSS = 0 def do_ping(host): #print(host) for i in range(1,6): start_polling = datetime.now().strftime(CLOCK_STR) gateway = ping(host, count=5, interval=0.1, timeout=0.5) rtt = gateway.avg_rtt loss = gateway.packet_loss end_polling = datetime.now().strftime(CLOCK_STR) if rtt > SOGLIA_RTT or loss > SOGLIA_LOSS: print(f'{host}, {start_polling}||{end_polling}, {rtt}, {loss}') time.sleep(0.5) threads = [] # Creazione e avvio dei thread for host in host_list: thread = threading.Thread(target=do_ping, args=(host,)) threads.append(thread) thread.start() # Attesa che tutti i thread terminino for thread in threads: thread.join() print(\"Tutti i thread sono terminati.\")","title":"Python"},{"location":"dev/python/#python","text":"","title":"Python"},{"location":"dev/python/#show-python-path","text":"python3 -c \"import sys;print('\\n'.join(sys.path))\"","title":"Show Python PATH"},{"location":"dev/python/#modulenotfounderror-in-virtualenv","text":"Si risolve puntanto al percorso python nel virtualenv sudo venv/bin/python3 main.py","title":"ModuleNotFoundError in virtualenv"},{"location":"dev/python/#datetime","text":"now = datetime.now().strftime(CLOCK_STR))","title":"Datetime"},{"location":"dev/python/#icmplib","text":"from icmplib import ping import time from datetime import datetime import threading #CLOCK_STR = \"%m/%d/%Y, %H:%M:%S\" CLOCK_STR = \"%H:%M:%S.%f\" host_list = [\"192.168.1.1\", \"dns.google.com\"] #host_list = [\"repubblica.it\", \"dns.google.com\"] SOGLIA_RTT = 10 SOGLIA_LOSS = 0 def do_ping(host): #print(host) for i in range(1,6): start_polling = datetime.now().strftime(CLOCK_STR) gateway = ping(host, count=5, interval=0.1, timeout=0.5) rtt = gateway.avg_rtt loss = gateway.packet_loss end_polling = datetime.now().strftime(CLOCK_STR) if rtt > SOGLIA_RTT or loss > SOGLIA_LOSS: print(f'{host}, {start_polling}||{end_polling}, {rtt}, {loss}') time.sleep(0.5) threads = [] # Creazione e avvio dei thread for host in host_list: thread = threading.Thread(target=do_ping, args=(host,)) threads.append(thread) thread.start() # Attesa che tutti i thread terminino for thread in threads: thread.join() print(\"Tutti i thread sono terminati.\")","title":"icmplib"}]}