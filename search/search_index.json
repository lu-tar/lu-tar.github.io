{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My wiki Simple Wiki to track notes and code snippets.","title":"My wiki"},{"location":"#my-wiki","text":"Simple Wiki to track notes and code snippets.","title":"My wiki"},{"location":"dev/haproxy/","text":"HAproxy HAproxy docs Come fare routing tra diversi servizi usando il nome DNS. Progetto di laboratorio, non replicare in produzione. Setup: - entry point (firewall): espone sull'interffaccia outside la VM con HA Proxy su porta 80 - il DNS locale risolve i nomi seguenti con l'ip dell'entry point (outside firewall): - factorio-1.lab - firefly.lab HA proxy fa smistamento del traffico in base al nome in entrata riducendo i NAT sul firewall per ogni applicazione a discapito della sicurezza. factorio-1.lab > 10.0.2.3:80/health firefly.lab > 10.0.5.1:3001 NB: necessario che l'entry point sia raggiunbile in porta 443 per maggiore sicurezza. L'utilizzo della porta 80 \u00e8 una pigrizia da laboratorio. # Force the apt package management tool to assume \u201cyes\u201d to any questions that pop-up during the installation process.s sudo apt install haproxy -y cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak nano /etc/haproxy/haproxy.cfg # Verifica integrit\u00e0 della configurazione haproxy -c -f /etc/haproxy/haproxy.cfg sudo systemctl restart haproxy sudo systemctl status haproxy sudo tail -f /var/log/haproxy.log global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin stats timeout 30s user haproxy group haproxy daemon # Default SSL material locations ca-base /etc/ssl/certs crt-base /etc/ssl/private # See: https://ssl-config.mozilla.org/#server=haproxy&server-version=2.0.3&config=intermediate ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384 ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256 ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets defaults log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 errorfile 400 /etc/haproxy/errors/400.http errorfile 403 /etc/haproxy/errors/403.http errorfile 408 /etc/haproxy/errors/408.http errorfile 500 /etc/haproxy/errors/500.http errorfile 502 /etc/haproxy/errors/502.http errorfile 503 /etc/haproxy/errors/503.http errorfile 504 /etc/haproxy/errors/504.http frontend http_front bind *:80 acl host_factorio hdr(host) -i factorio-1.lab acl host_firefly hdr(host) -i firefly.lab use_backend factorio_backend if host_factorio use_backend firefly_backend if host_firefly default_backend default_backend backend factorio_backend # L'API custom del server \u00e8 raggiungibile solo su /health http-request set-path /health server factorio_server 10.0.2.3:80 check backend firefly_backend server firefly_server 10.0.5.1:3001 check backend default_backend errorfile 503 /etc/haproxy/errors/503.http","title":"HAproxy"},{"location":"dev/haproxy/#haproxy","text":"HAproxy docs Come fare routing tra diversi servizi usando il nome DNS. Progetto di laboratorio, non replicare in produzione. Setup: - entry point (firewall): espone sull'interffaccia outside la VM con HA Proxy su porta 80 - il DNS locale risolve i nomi seguenti con l'ip dell'entry point (outside firewall): - factorio-1.lab - firefly.lab HA proxy fa smistamento del traffico in base al nome in entrata riducendo i NAT sul firewall per ogni applicazione a discapito della sicurezza. factorio-1.lab > 10.0.2.3:80/health firefly.lab > 10.0.5.1:3001 NB: necessario che l'entry point sia raggiunbile in porta 443 per maggiore sicurezza. L'utilizzo della porta 80 \u00e8 una pigrizia da laboratorio. # Force the apt package management tool to assume \u201cyes\u201d to any questions that pop-up during the installation process.s sudo apt install haproxy -y cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak nano /etc/haproxy/haproxy.cfg # Verifica integrit\u00e0 della configurazione haproxy -c -f /etc/haproxy/haproxy.cfg sudo systemctl restart haproxy sudo systemctl status haproxy sudo tail -f /var/log/haproxy.log global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin stats timeout 30s user haproxy group haproxy daemon # Default SSL material locations ca-base /etc/ssl/certs crt-base /etc/ssl/private # See: https://ssl-config.mozilla.org/#server=haproxy&server-version=2.0.3&config=intermediate ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384 ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256 ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets defaults log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 errorfile 400 /etc/haproxy/errors/400.http errorfile 403 /etc/haproxy/errors/403.http errorfile 408 /etc/haproxy/errors/408.http errorfile 500 /etc/haproxy/errors/500.http errorfile 502 /etc/haproxy/errors/502.http errorfile 503 /etc/haproxy/errors/503.http errorfile 504 /etc/haproxy/errors/504.http frontend http_front bind *:80 acl host_factorio hdr(host) -i factorio-1.lab acl host_firefly hdr(host) -i firefly.lab use_backend factorio_backend if host_factorio use_backend firefly_backend if host_firefly default_backend default_backend backend factorio_backend # L'API custom del server \u00e8 raggiungibile solo su /health http-request set-path /health server factorio_server 10.0.2.3:80 check backend firefly_backend server firefly_server 10.0.5.1:3001 check backend default_backend errorfile 503 /etc/haproxy/errors/503.http","title":"HAproxy"},{"location":"dev/linux/","text":"Linux netplan ubuntu server static configuration # This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: enp0s3: addresses: - 10.0.0.1/24 nameservers: addresses: - 10.0.0.2 search: [] routes: - to: default via: 10.0.0.254 version: 2 dhcp configuration network: ethernets: enp0s3: dhcp4: true version: 2 usermod usermod -aG sudo username Adding k9s o binari a PATH # If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH export PATH=/usr/lib/python3.10:$PATH export PATH=/snap/k9s/current/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"$HOME/.oh-my-zsh\" Homebrew installation /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" (echo; echo 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"') >> /home/luca/.bashrc eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\" sudo apt-get install build-essential","title":"Linux"},{"location":"dev/linux/#linux","text":"","title":"Linux"},{"location":"dev/linux/#netplan-ubuntu-server","text":"","title":"netplan ubuntu server"},{"location":"dev/linux/#static-configuration","text":"# This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: enp0s3: addresses: - 10.0.0.1/24 nameservers: addresses: - 10.0.0.2 search: [] routes: - to: default via: 10.0.0.254 version: 2","title":"static configuration"},{"location":"dev/linux/#dhcp-configuration","text":"network: ethernets: enp0s3: dhcp4: true version: 2","title":"dhcp configuration"},{"location":"dev/linux/#usermod","text":"usermod -aG sudo username","title":"usermod"},{"location":"dev/linux/#adding-k9s-o-binari-a-path","text":"# If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH export PATH=/usr/lib/python3.10:$PATH export PATH=/snap/k9s/current/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"$HOME/.oh-my-zsh\"","title":"Adding k9s o binari a PATH"},{"location":"dev/linux/#homebrew-installation","text":"/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" (echo; echo 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"') >> /home/luca/.bashrc eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\" sudo apt-get install build-essential","title":"Homebrew installation"},{"location":"dev/microservices/","text":"Microservices In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. From https://martinfowler.com/articles/microservices.html Kubectl https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client","title":"Microservices"},{"location":"dev/microservices/#microservices","text":"In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. From https://martinfowler.com/articles/microservices.html","title":"Microservices"},{"location":"dev/microservices/#kubectl","text":"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client","title":"Kubectl"},{"location":"dev/mkdocs/","text":"Mkdocs doc: https://www.mkdocs.org/user-guide/writing-your-docs/ Installazione python3 -m venv venv source venv/bin/activate python3 -m pip install mkdocs pip freeze > requirements.txt echo \"venv/\" >> .gitignore echo \"site/\" >> .gitignore Local dev mkdocs serve Update code mkdocs build mkdocs gh-deploy --config-file ../mkdocs.yml --remote-branch main","title":"Mkdocs"},{"location":"dev/mkdocs/#mkdocs","text":"doc: https://www.mkdocs.org/user-guide/writing-your-docs/","title":"Mkdocs"},{"location":"dev/mkdocs/#installazione","text":"python3 -m venv venv source venv/bin/activate python3 -m pip install mkdocs pip freeze > requirements.txt echo \"venv/\" >> .gitignore echo \"site/\" >> .gitignore","title":"Installazione"},{"location":"dev/mkdocs/#local-dev","text":"mkdocs serve","title":"Local dev"},{"location":"dev/mkdocs/#update-code","text":"mkdocs build mkdocs gh-deploy --config-file ../mkdocs.yml --remote-branch main","title":"Update code"},{"location":"dev/python/","text":"Python Show Python PATH python3 -c \"import sys;print('\\n'.join(sys.path))\" ModuleNotFoundError in virtualenv Si risolve puntanto al percorso python nel virtualenv sudo venv/bin/python3 main.py Datetime now = datetime.now().strftime(CLOCK_STR)) icmplib from icmplib import ping import time from datetime import datetime import threading #CLOCK_STR = \"%m/%d/%Y, %H:%M:%S\" CLOCK_STR = \"%H:%M:%S.%f\" host_list = [\"192.168.1.1\", \"dns.google.com\"] #host_list = [\"repubblica.it\", \"dns.google.com\"] SOGLIA_RTT = 10 SOGLIA_LOSS = 0 def do_ping(host): #print(host) for i in range(1,6): start_polling = datetime.now().strftime(CLOCK_STR) gateway = ping(host, count=5, interval=0.1, timeout=0.5) rtt = gateway.avg_rtt loss = gateway.packet_loss end_polling = datetime.now().strftime(CLOCK_STR) if rtt > SOGLIA_RTT or loss > SOGLIA_LOSS: print(f'{host}, {start_polling}||{end_polling}, {rtt}, {loss}') time.sleep(0.5) threads = [] # Creazione e avvio dei thread for host in host_list: thread = threading.Thread(target=do_ping, args=(host,)) threads.append(thread) thread.start() # Attesa che tutti i thread terminino for thread in threads: thread.join() print(\"Tutti i thread sono terminati.\")","title":"Python"},{"location":"dev/python/#python","text":"","title":"Python"},{"location":"dev/python/#show-python-path","text":"python3 -c \"import sys;print('\\n'.join(sys.path))\"","title":"Show Python PATH"},{"location":"dev/python/#modulenotfounderror-in-virtualenv","text":"Si risolve puntanto al percorso python nel virtualenv sudo venv/bin/python3 main.py","title":"ModuleNotFoundError in virtualenv"},{"location":"dev/python/#datetime","text":"now = datetime.now().strftime(CLOCK_STR))","title":"Datetime"},{"location":"dev/python/#icmplib","text":"from icmplib import ping import time from datetime import datetime import threading #CLOCK_STR = \"%m/%d/%Y, %H:%M:%S\" CLOCK_STR = \"%H:%M:%S.%f\" host_list = [\"192.168.1.1\", \"dns.google.com\"] #host_list = [\"repubblica.it\", \"dns.google.com\"] SOGLIA_RTT = 10 SOGLIA_LOSS = 0 def do_ping(host): #print(host) for i in range(1,6): start_polling = datetime.now().strftime(CLOCK_STR) gateway = ping(host, count=5, interval=0.1, timeout=0.5) rtt = gateway.avg_rtt loss = gateway.packet_loss end_polling = datetime.now().strftime(CLOCK_STR) if rtt > SOGLIA_RTT or loss > SOGLIA_LOSS: print(f'{host}, {start_polling}||{end_polling}, {rtt}, {loss}') time.sleep(0.5) threads = [] # Creazione e avvio dei thread for host in host_list: thread = threading.Thread(target=do_ping, args=(host,)) threads.append(thread) thread.start() # Attesa che tutti i thread terminino for thread in threads: thread.join() print(\"Tutti i thread sono terminati.\")","title":"icmplib"}]}